import pandas as pd
import random
###################################################################################
############### Make a class for matching process##################################
###################################################################################

class MatchingAlgorithm:
    def __init__(self, t, df, n_rd, n_p, v_cap, N):
        self.t = t
        self.df = df
        self.n_rd = n_rd
        self.n_p = n_p
        self.mode = 'NA'
        self.partners =[]
        self.v_cap = v_cap
        self.N = N

    def fifo(self):

        self.mode = 1
        # if # of waiting passengers >= 1, then
        if self.n_p >= self.v_cap:
            n_matched_p = self.v_cap
            self.n_p -= self.v_cap
        else:
            # When the number of waiting passengers exceeds capacity, the number of finally matched passengers will be the number of waiting passengers
            n_matched_p = self.n_p
            self.n_p -= self.n_p

        # get partners
        iter_t = 0
        # self.t is the time step when doing matching process
        #iter_tis used in while loop in order to check that who is the first waiting passenger
        while n_matched_p != 0 and iter_t < self.t: # if false, stop
            role = self.df.loc[iter_t, 'P_D'] # DataFrame.loc[行，列]
            partner = self.df.loc[iter_t, 'partner']
            pax_id = (self.df.loc[iter_t, 'ID'])

            if role == 'P' and partner == '-':# If agent is P and he or she hasn't been matched(partner = '-'), record that number in a list which include waiting partners
                self.partners.append((pax_id))
                n_matched_p -= 1
            else:
                pass
            iter_t += 1

    def rank(self):
        # This matching algorithm lets driver to select his own passengers
        #   in case number of passengers is larger than vehicle's capacity.
        # Selection criteria is according to driver's ranking.
        # Current ranking is generated by specify random seed, such that it can be reproduced.
        # In future, ranking should be obtained from utility function.
        self.mode = 1
        df_now = self.df.head(self.t+1)
        df_avail_pax = df_now[df_now.P_D.isin(['P']) & df_now.partner.isin(['-'])]
        if self.n_p <= self.v_cap:
            # if #available pax is less than or equal to v_cap, driver takes all pax
            self.n_p = 0
            for index, pax in df_avail_pax.iterrows():
                self.partners.append(pax['ID'])
        else:
            # if #available pax is more than v_cap, driver can choose pax
            pax_list = pd.DataFrame()
            i = 0
            for index, pax in df_avail_pax.iterrows():
                # randomly give rank using driver id as seed, and pas id as index
                # this should be properly write as separated utility function later on
                d_ID = self.df.loc[self.t, 'ID']
                p_ID = pax['ID']
                pax_list.loc[i, 'ID'] = p_ID
                pax_list.loc[i, 'rank'] = random.Random(d_ID).sample(range(self.N),self.N)[p_ID]
                i += 1
            for index, pax in pax_list.nsmallest(self.v_cap,'rank').iterrows():
                self.partners.append(int(pax['ID']))
            self.n_p -= self.v_cap


    def run_matching(self, matching_algorithm):
        self.n_rd += 1
        if self.n_rd > 0 and self.n_p > 0:
            if matching_algorithm == "fifo":
                self.fifo()
            elif matching_algorithm == 'rank':
                self.rank()
            else:
                print("ERROR: please define correct matching algorithm: fifo, rank, ..")
        else:# When running matching, the driver chooses ride-sharing and there is a passenger, so else should not exist
            print("WARN: Matching wasn't executed due to insufficient agents")

    def get_N_rd(self):
        return self.n_rd

    def get_N_p(self):
        return self.n_p

    def get_mode(self):
        return self.mode

    def get_partners(self):
        return self.partners


def main():
    t = 3
    agentID = [11, 12, 13, 14]
    PorD = ['P', 'P', 'P', 'D']
    partner = ['-', '-', '-', '-']
    n_rd = 0
    n_p = 3
    v_cap = 2
    N = 100
    d = {'P_D': PorD, 'ID': agentID, 'partner': partner}
    df = pd.DataFrame(d)
    ma = MatchingAlgorithm(t, df, n_rd, n_p, v_cap, N)
    ma.run_matching('rank')

    print('N_rd', ma.get_N_rd(), n_rd)
    print('N_p', ma.get_N_p(), n_p)
    print('partners', ma.get_partners())
    print('mode', ma.get_mode())


# below two lines are to avoid "immediately running after import this
# module from another file"
if __name__ == "__main__":
    main()


